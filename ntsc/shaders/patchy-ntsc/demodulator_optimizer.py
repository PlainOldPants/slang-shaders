# This code was generated by ChatGPT on August 28, 2024.

import numpy as np
from scipy.optimize import minimize
import colour
import math

# Define SMPTE-C RGB color bars (normalized to [0, 1])
smpte_c_rgb = np.array([
    [0.5, 0.5, 0.5],  # White
    [0.5, 0.5, 0.0],  # Yellow
    [0.0, 0.5, 0.5],  # Cyan
    [0.0, 0.5, 0.0],  # Green
    [0.5, 0.0, 0.5],  # Magenta
    [0.5, 0.0, 0.0],  # Red
    [0.0, 0.0, 0.5],  # Blue
    [0.0, 0.0, 0.0]   # Black
])

# Convert RGB to Jzazbz
def rgb_to_jzazbz(rgb):
    XYZ = colour.sRGB_to_XYZ(rgb)
    Jzazbz = colour.XYZ_to_Jzazbz(XYZ)
    return Jzazbz

# Convert RGB to YUV using a custom matrix
def rgb_to_yuv(rgb, matrix):
    return np.dot(matrix, rgb.T).T

# Convert YUV to RGB using a custom matrix
def yuv_to_rgb(yuv, matrix):
    return np.dot(matrix, yuv.T).T

# Apply hue rotation and saturation scaling
def adjust_uv(yuv, hue_rotation, saturation_scale):
    U, V = yuv[:, 1], yuv[:, 2]
    theta = np.deg2rad(hue_rotation)
    cos_theta, sin_theta = np.cos(theta), np.sin(theta)
    
    U_prime = cos_theta * U - sin_theta * V
    V_prime = sin_theta * U + cos_theta * V
    
    U_prime *= saturation_scale
    V_prime *= saturation_scale
    
    return np.stack((yuv[:, 0], U_prime, V_prime), axis=-1)

# Optimization target function
def optimization_target(params, smpte_c_rgb, smpte_c_jzazbz, yuv_matrix, rgb_matrix):
    hue_rotation, saturation_scale = params
    yuv = rgb_to_yuv(smpte_c_rgb, yuv_matrix)
    adjusted_yuv = adjust_uv(yuv, hue_rotation, saturation_scale)
    adjusted_rgb = yuv_to_rgb(adjusted_yuv, rgb_matrix)
    adjusted_jzazbz = np.array([rgb_to_jzazbz(rgb) for rgb in adjusted_rgb])
    
    # Compute the sum of squared Euclidean differences in Jzazbz space
    diff = smpte_c_jzazbz - adjusted_jzazbz
    return np.sum(np.linalg.norm(diff, axis=1))

# Example non-standard YUV and RGB matrices (replace these with actual matrices)

# Standard matrix for encoding
yuv_matrix = np.array([
    [0.299, 0.587, 0.114],
    [-0.14713, -0.28886, 0.436],
    [0.615, -0.51499, -0.10001]
])

# Nonstandard matrix for decoding
r_off = 112.0 / 180.0 * math.pi
r_max = 0.83
g_off = 252.0 / 180 * math.pi
g_max = 0.3
b_off = 0.0
b_max = 1.0

rgb_matrix = np.array([
    [1, r_max * math.cos(r_off), r_max * math.sin(r_off)],
    [1, g_max * math.cos(g_off), g_max * math.sin(g_off)],
    [1, b_max * math.cos(b_off), b_max * math.sin(b_off)]
])

# Gamma correct the SMPTE-C RGB colors and convert to Jzazbz
smpte_c_jzazbz = np.array([rgb_to_jzazbz(rgb) for rgb in smpte_c_rgb])

# Initial guesses for hue rotation and saturation scale
initial_params = [0.0, 1.0]

# Optimize hue rotation and saturation scaling
result = minimize(optimization_target, initial_params, args=(smpte_c_rgb, smpte_c_jzazbz, yuv_matrix, rgb_matrix))
optimized_hue_rotation, optimized_saturation_scale = result.x

print(f"Optimized Hue Rotation: {optimized_hue_rotation} degrees")
print(f"Optimized Saturation Scale: {optimized_saturation_scale}")

